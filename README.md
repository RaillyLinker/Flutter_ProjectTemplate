# Flutter Project Template

[프로젝트 설명]

- 본 프로젝트는 재활용이 가능하도록(복사 붙여넣기가 가능하도록) 다양한 환경, 다양항 상황을 가정하여 만들어졌습니다.
- 코드 내 모든 요소엔 되도록 이해가 쉽도록, 주석을 사용하여 설명이 달아두었습니다.
  주석 중, !!!무엇무엇을 하시오!! 이런식으로 !!! 와 !! 로 감싸진 부분이 존재한다면 해당 부분이 설명한 방식대로 커스텀이 가능하다는 뜻입니다.
  복사 붙여넣기를 사용하는 보일러 플레이트 코드가 꽤 존재하는데, 이때는 복사된 파일 내의 !!! 주석 지시에 따라 커스텀을 하고,
  나머지 부분은 그대로 두면 됩니다.
  각 파일별 find 기능으로 !!! 부분을 찾아서 수정하면 용이합니다.
- 본 프로젝트는 MVVM 패턴과 BLoC 패턴, 레포지토리 패턴을 사용합니다.
  이에 개발자가 구현해야할 대표적 요소는, Model(Repository), View, ViewModel 과 더불어 Business Logic 이 존재합니다.
- 본 설명글은 이해를 돕기 위하여, 선행 지식과 앱 실행 흐름에 따라 항목을 순서대로 배치하였습니다.
  아래 항목들의 설명글을 읽을 때에는 각 항목별 표시된 파일들을 실제로 열어서 비교하며 읽어나가면 이해에 도움이 될 것입니다.

[용어 정리]

- 페이지 : 겉으로 보여지는 화면 요소와 내부적, 프로그래밍적으로 처리되는 로직 요소가 한 세트를 이루고 있는
  화면 단위 코드 묶음을 '페이지'라고 하겠습니다.
- MVVM & BLoC :
  Model 은 앱 내부에서 사용할 데이터로 생각하면 되며, Repository 가 이를 다루고 접근하는 역할을 할 것입니다.
  View 는 외부에 제공되는 화면 UI를 뜻하며, 플러터에선 위젯이라는 객체로 이를 구현합니다.
  ViewModel 은 View 의 상태 데이터를 뜻합니다. View 의 위젯 중에는 런타임에 비즈니스 로직에 따라 변화되는 부분도 존재하는데,
  그때의 화면 상태의 정보를 모아둔 것입니다.
  Business Logic 은 프로그램의 로직을 담당하여, 특정 로직에 대한 함수를 View 나 다른 Business 함수에게 제공하는 역할을 합니다.
  화면을 뜻하는 View
  데이터를 뜻하는 ViewModel, Model(Repository)
  로직을 뜻하는 Business Logic
  위와 같은 요소들을 프로젝트 내부에서 구조적으로 나누어 코드 해석과 유지보수를 용이하게 하였습니다.
- 프로그램 : 본 프로젝트가 구현하고자 하는 것은 어플리케이션(응용 프로그램)입니다.
  보통 어플리케이션, 앱이라고 하면 모바일 앱을 떠올리기에,
  여기선 모든 플랫폼을 아우르는 응용 프로그램을 모두 뭉뚱그려서 프로그램이라 부르겠습니다.
- PC, Mobile, Web :
  디바이스별 프로그램을 구분지어 이렇게 부르며,
  정확히 표현하자면 PC 어플리케이션, Mobile 어플리케이션, Web 어플리케이션입니다.
  이를 줄여 표현한 것입니다.
- App :
  PC 와 Mobile 을 합친 것을 App 이라 부르겠습니다.
  정리하자면, 프로그램 안에 App, Web 이 있고, App 안에 PC, Mobile 이 있으며, PC 안에 linux, windows, mac.
  Mobile 안에 ios, android 로 세분되는 것입니다.
- Repository :
  시간적, 관리적으로 코스트가 많이 들어가는 저장소(network, SharedPreferences, Database)에 대한 접근, 조작을 담당합니다.
- 계정 관련 용어 정리 :
  로그인 : Login
  로그아웃 : Logout
  회원가입 : join the membership
  회원탈퇴 : Withdrawal
  회원 : Member
  비회원 : non member
  서비스 이용자 (비회원 포함) : User

[멀티 플랫폼 요소]

- 멀티 플랫폼 프레임워크인 Flutter 에서 한개 이상의 플렛폼을 겨냥한 개발을 진행할 때,
  상황에 따라 구현해야할 View 와 ViewModel, Business Logic 에 차이가 존재할 수 있습니다.
  예를들면 App 이 시작될 때에는 스플래쉬 페이지로 진입하여 여기서 전처리를 수행하며, 각 페이지간의 이동이 정해진 경로를 가지지만,
  Web 의 경우는 브라우저 주소창으로 자유롭게 경로 이동이 가능함을 인식하고 개발을 해야합니다.
- 앱과 웹은 UX 적으로 차이가 존재합니다.
  앱은 최초 진입 페이지에서부터 일련의 흐름으로 화면이 유기적으로 연결됩니다.
  이전 페이지의 메모리상 정보가 다음 페이지로 전달되고, 페이지간의 이동은 무조건 화면 내의 요소의 조작에 달린 것입니다.
  하지만 웹은 각 페이지를 따로 놓고봅니다.
  진입을 위한 address 와 parameter 로 그때 그때 페이지를 완성시킨다는 개념입니다.
  이러한 차이를 무시하여, 웹을 모바일 앱처럼 그대로 만들었을 때에는 유저에게 '뭔가 일반적인 웹과는 다른 생소함'을 일으킬 수 있습니다.
- 대부분의 경우, 앱과 웹은 비즈니스 로직과 흐름 등의 큰 타이로 인하여 분리되어 작성하는 것이 좋습니다.
  플러터 프로젝트에서는 웹을 만드는 것이 앱을 만드는 것보다 처리해야 할 요소(상태 처리, SEO 처리 등)가 많습니다.
  웹을 상정하고 만든 페이지는 앱에도 그대로 사용이 가능한 경우가 많으며, 앱을 상정하고 만든 페이지는 웹에서 동작할 때 좋지 않은 기능을 할 수가 있습니다.
  그렇기에 모든 플렛폼을 가정할 때에는 먼저 웹(PC 브라우저 화면 + 모바일 브라우저 화면 고려)을 먼저 만드는 편이 재활용에 좋습니다.
- 앱과 웹의 차이 외에도 다양한 상황에 따라 동일 프로젝트를 구현하면서도 다른 Logic, 다른 View 를 적용하고 싶을 수가 있을 것입니다.
  예를들면 ios 와 android 간의 UI 차이, 화면 해상도에 따른 UI 차이, 모바일 앱과 PC 앱 간의 Logic 차이 등
  다양한 변화 요인들이 존재할 수 있습니다.
  Logic 과 View 에 영향을 주는 요인들을 정리하자면,
  정적으로는 구동 환경(app(mobile(ios, android), pc(windows, linux, mac)), web)의 차이,
  동적으로는 화면 크기, 화면 비율, 테마(나이트 모드, 데이 모드), 사용 언어 설정, 그외 비즈니스 로직의 수행 결과가 있습니다.
- 정적 요소들은 페이지를 구성하는 단계에서 결정되어 런타임에선 변경되지 않지만,
  동적 요소들은 런타임에도 상황의 변화에 따라 자유롭게 변경이 가능해야합니다.
- 본 프로젝트와 설명글은, 위와 같은 상황들에 대처가 가능하도록, 그럼에도 코드 구조가 깔끔하고 개발이 쉽도록 해법을 제시합니다.

[작명법]

- 본 프로젝트의 폴더 및 파일은 Snake 표기법을 사용합니다. (import 할 때 dart 표준 표기법과 맞추기 위하여)
- 코드 내의 작명법은 Dart 언어 기본 작명방식을 따릅니다.
- 파일 / 폴더명은 되도록 고유성을 띄며, 너무 길거나 난해하지 않고, 의미를 한눈에 파악할 수 있는 것이 좋습니다.
  본 프로젝트에선, import 했을 때, 별명을 붙이는 시점에서 그대로 복사 붙여넣기를 할 수 있고,
  더불어 다른 파일명과의 충돌을 피하는 것을 중점으로 작명하였습니다.
- 대표적으로 파일 / 폴더명에 접두어를 사용합니다.
  의미를 나타내지만, 겹칠수 있는 이름 앞에, 그 파일/폴더 고유의 의미를 지닌 접두어를 붙임으로써 중복을 피하고 의미를 강화했습니다.
- 더 자세한 작명법 규칙, 몇가지 정해진 변수명, 클래스명이나 정해진 패턴을 가진 이름 등은
  프로젝트에 제공된 코드와 주석, 그리고 아래 항목의 설명글을 참고하세요.
- async 를 사용하는 비동기 함수는 함수명 뒤에 Async 라는 접미어를 붙입니다.

[환경 분류 접두어]

- 파일, 폴더명을 만들 때, 정적, 동적 환경에 따라 일정한 규칙을 지닌 명명법이 존재합니다.
  보통 이런 조건을 파일명 앞에 두는데,
  통일성을 위하여, 자주 쓰이는 작명법을 추천드립니다.
- 정적 환경 접두어 예시
  all (web, app (mobile(ios, android), pc(windows, linux, mac)))
- 동적 환경 접두어 예시
  all (portrait, landscape, max_width_400, min_height_500)

[개발 및 빌드시 주의사항]

- 본 프로젝트는 구동환경에 따라 파일을 분리하는 방식을 사용합니다.
  이에 따라 환경에 따른 코드 분리는 깔끔하게 이뤄지지만,
  각 환경별 사용되지 않는 파일, 클래스, 함수, 변수가 늘어날 수 있습니다.
  예를들면, 프로젝트 내에 web, mobile, pc 를 모두 고려한 개발을 진행하면서 각 환경별 다른 동작을 하도록 설계했을 때,
  web 에서만 사용되는 파일과 mobile 에서만 사용되는 파일, pc 에서만 사용되는 파일이 한 프로젝트에 혼재된 상태입니다.
  web 환경에서 본 프로젝트를 실행한다고 가정할때,
  해당 상황에선 web 로직에만 사용되는 파일만을 사용하고, 나머지는 사용되지도 않을 것입니다.
  정상적으로 작성을 했다면 그렇게까지 크게 성능상 문제를 일으키지는 않을테지만,
  프로젝트 크기가 커짐에 따라, 빌드 시간과 앱 용량, 심지어 설계에 따라서는 메모리, CPU 연산량에도 악영향을 줄 수 있음을 주의하며 개발을 하면 됩니다.

[인증 / 인가]

- 본 프로젝트가 서버와 연동하는 인증 / 인가 방식은 JWT Token 인증 방식을 사용합니다.
- 사용 방식은 아래와 같습니다.

1. 클라이언트는 서버에 본인을 증명하는 로그인 정보를 입력하고, 서버는 해당 정보가 이상이 없다면, 액세스 토큰(대략 유효기간 30분),
   리플래시 토큰(대략 유효기간 7일)을 발행할 것인데, 클라이언트는 리플래시 토큰을 비휘발성 저장소에, 액세스 토큰은 메모리에 저장해둡니다.
2. 인증 / 인가가 필요한 네트워크 API 를 호출시 액세스 토큰을 리퀘스트에 같이 보내줍니다.
   액세스 토큰 내에는 암호화된 유저 정보가 들어있으므로 서버는 이를 해석하여 접근 권한을 확인하고, 적절한 정보를 반환할 것입니다.
3. 만약 액세스 토큰이 만료되어 해당하는 실패 신호가 반환된다면, 저장된 리플래시 토큰으로 새로운 액세스 토큰,
   리플래시 토큰을 발급받아 저장해둡니다. 또한 앞서 실패한 네트워크 API 를 재요청합니다.
4. 만약 토큰 재발급시 리플래시 토큰마저도 만료되었다고 실패 신호가 반환되면, 이때는 유저에게 재 로그인을 요청해야 합니다.

[아래 부터는 lib 폴더 안의 폴더 / 파일 설명]

[a_templates]

- 본 프로젝트는 동일한 형식으로 자주 사용되는 코드를 재활용이 가능하도록 정리하여 제공합니다.
  a_templates 는 파일/폴더 단위로 자주 사용되는 코드를 모아둔 곳으로,
  예를들면 새로운 다이얼로그를 만들 때마다 동일하게 사용되는 파일들을 모아둔 폴더,
  새로운 페이지를 만들 때마다 동일하게 사용되는 파일들을 모아둔 폴더 등이 보관되어 있으므로,
  이를 복사하여 적절한 장소에 붙여넣은 후, 파일 안의 전체 코드의 주석을 풀고, !!! 로 시작되는 주석 부분을 수정하는 방식으로
  다양한 기능에 대응하고 안정적인 동작을 하도록 미리 구조가 작성된 코드를 쉽고 빠르게 개발이 가능합니다.

[a_templates/all_dialog_template]

- 새로운 다이얼로그를 생성할 때 복사하여 사용할 수 있습니다.

[a_templates/all_page_template]

- 새로운 페이지를 생성할 때 복사하여 사용할 수 있습니다.

[a_templates/api_template.dart]

- 새로운 Network API 요청 파일을 생성할 때 복사하여 사용할 수 있습니다.
- 내부에는 네트워크의 기본 요청 방식들에 대한 샘플 코드가 존재하므로 참고하면 좋습니다.

[a_templates/spw_template.dart]

- 새로운 SPW 파일을 생성할 때 복사하여 사용할 수 있습니다.

[main.dart]

- 프로그램의 첫 진입점이라 할 수 있는 main 함수가 작성되어 있는 파일입니다.
- 여기서 프로그램 최초 실행시에 수행할 로직을 작성 합니다.

[router.dart]

- 라우터란, 페이지 단위로 이동할 경로를 지정하는 것을 의미합니다.
  모든 페이지는 라우터에 저장되어 있어야 코드상 페이지 이동이 가능합니다.
- 페이지 구현시 해당 화면에 필요한 필수 정보는 웹을 고려하여, 내부 메모리가 아닌 url parameter 로 받아들이도록 설정합니다.
- 첫 화면에서 순서대로 진행되는 앱과 달리, 웹은 브라우저 주소창에 주소를 입력하는 것으로 화면상 경로가 정해지지 않은 페이지로
  자유롭게 이동 가능합니다. 고로, 웹 개발시엔 페이지 경로 설계는 이를 고려합시다.
- 여기서 프로그램 실행시 사용할 페이지 목록과 최초로 진입하는 페이지의 주소를 설정합니다.
  정적 환경별 시작 경로를 설정하고, 사용할 페이지를 추가하면 됩니다.
- 라우터 안에 라우터를 설정한 서브 라우터가 기능상 제공됩니다.
- 본 프로젝트의 route 설정에는 name 을 적용하고 활용할 것입니다.
  route 의 path 는 웹브라우저상의 path 를 말한다면, name 은 프로그램 내부에서 사용할 이름입니다.
  후술할 페이지의 page_entrance.dart 에서 이를 정의하고, context.pushNamed() 이나 context.goNamed() 와 같은 함수로
  해당 이름을 설정한 페이지 라우트로 이동이 가능합니다.

[GoRouter 라이브러리 사용 (program_router.dart)]

- 본 프로젝트 라우팅 처리는 Navigator2.0 을 보다 사용하기 쉽게 제공해주는 GoRouter 를 사용합니다.
  아래는 간단한 사용 방식을 정리한 것입니다.
- 페이지 호출 예시 :
  context.push("/test/test2?param1=testparam");
  context.go("/test/test2?param1=testparam");
  context.pushNamed("testName",
  queryParameters: {
  "testInt": "1", // String 타입 외의 파라미터를 전달하더라도 호출시의 인자값은 String 타입을 사용해야함.
  });
- 히스토리 뒤로가기 : context.pop(); context.pop(OutputVo("test Return"));
- Query 파라미터 받기 : 핸들러에서 String? param1 = state.queryParams['param1']; 이런식으로 받습니다.
  파라미터 전달은, 브라우저 주소창이나, context.go 를 할 때, /test?param1 = parameter1 이렇게 입력합니다.
- path 파라미터 받기 : path 에, "/test/:param1" 이렇게 설정 후, String? param1 = state.params['param1']; 이런식으로
  받습니다.
  다만, 경로명 관리가 까다로워지므로 이는 사용하지 않도록 결정했습니다.

[assets]

- 프로그램 내부에서 사용할 에셋 파일을 모아둔 폴더입니다.
- 이곳에 파일을 저장했다면, 플러터 코딩 규칙에 따라 pubspec.yaml 하단에 적절한 에셋 설정을 해야 사용할 수 있습니다.
- 이미지 리소스 팁 : 해상도 변경에 따른 적절한 이미지 리소스를 사용하기 위하여, 총 6 종류 해상도의 이미지가 필요합니다.
  해상도는,
  ldpi (120dpi, 0.75x), mdpi (160dpi, 1.0x), hdpi (240dpi, 1.5x),
  xhdpi (320dpi, 2.0x), xxdpi (480dpi, 3.0x), xxxhdpi (640dpi, 4.0x)
  위와 같은 종류가 있으며, xxxhdpi 에 해당하는 이미지를 준비한 후, 각 배수에 맞게 해상도를 낮추는 방식으로 준비하면 좋습니다.
  정 안된다면, 1.0x 에 해당하는 mdpi 해상도 이미지만을 준비하고 나머지 배수의 이미지는 비워두는 방식을 사용해도 됩니다.

[global_classes/*]

- 전역에서 사용할 클래스를 모아둔 폴더입니다.
- 서브 파일명은 가장 앞에 gc_ 가 붙습니다.
- 서브 파일은 dart 파일이어야 하고, 내용은 vo 등의 전역 클래스를 선언하면 됩니다.

[global_data/*]

- 전역에서 사용할 데이터를 모아둔 폴더입니다.
- 메모리 오남용을 막기 위하여, 꼭 필요한 전역 데이터는 이 폴더 안에 모아둡니다.
- 서브 파일명은 가장 앞에 gd_ 가 붙습니다.
  또한 모아둔 데이터가 상수라면 gd_const, 모아둔 데이터가 변수라면 gd_variable 이라고 구분합니다.
- 서브 파일은 dart 파일이어야 하고, 내용은 전역 변수/상수를 저장하는 용도로 작성합니다.

[global_functions/*]

- 전역에서 사용할 함수를 모아둔 폴더입니다.
- 서브 파일명은 가장 앞에 gf_ 가 붙습니다.
- 서브 파일에 프로그램 전역에서 자주 사용하는 함수를 미리 작성해두고 사용하세요.

[repositories]

- 시간적, 관리적으로 코스트가 많이 들어가는 저장소(network, SharedPreferences, Database)에 대한 접근, 조작을 담당하는
  레포지토리 관련 폴더/파일을 저장하는 폴더입니다.
- 서브 폴더로 network, spws, database 가 존재합니다.

[repositories/network]

- 네트워크 레포지토리용 폴더입니다.

[repositories/network/network_repositories.dart]

- 네트워크 요청 객체를 선언, 생성, 설정하는 파일입니다.
- 네트워크 요청 라이브러리는 Dio 를 사용하며, 하나의 Dio 객체는 하나의 서버에 대응합니다.
- 파일 내에서 네트워크 요청 파일 선언, 생성과, 그에 대한 초기 설정을 커스텀하면 됩니다.

[repositories/network/apis]

- 네트워크 요청 함수를 선언, 구현한 파일입니다.
- 외부 코드에서 네트워크 요청을 보내는 것은 이곳에 작성된 요청 함수를 사용합니다.
- 하나의 서브 파일은 하나의 Dio 객체에 대응합니다.
- 서브 파일명은 앞에 api_ 가 붙습니다.

[spws]

- SharedPreferences 를 보다 쉽게 사용할수 있도록 래핑한 spw 파일들을 모아둔 폴더입니다.
- 서브 파일명은 앞에 spw_ 가 붙습니다.
- 서브파일 내의 SharedPreferences Key 는 서브 파일명을 그대로 사용합니다.
- Key 에 대응하는 Value 는 객체 타입으로, 실제로는 Json 형식의 String 으로 저장됩니다.
- 저장시엔 객체 타입 변수가 먼저 Map<String, dynamic> 타입으로 변경된 후, Json String 으로 변환되어 String 타입으로 저장이 되고,
  조회시엔 String 타입이 Json String 으로 해석되어 Map<String, dynamic> 타입으로 변경된 후, 객체 타입으로 변환이 되어 반환됩니다.
- 위와 같은 저장, 조회 로직에서 개발자가 할 일은, 저장시 객체 타입을 Map 타입으로 변환하는 것과,
  조회시 Map 타입을 객체 타입으로 변환하는 작업을 수동으로 해주어야 합니다.
- SharedPreferences 저장에는 암호화가 들어갑니다.
  Key 도, Value 인 JsonString 도 모두 AES256 암호화를 거쳐서 로컬에 저장됩니다.
  이때 Key 의 암호화는 모든 SPW 가 동일한 암호화 키를 공유하여 사용하여, 중복을 방지하였습니다.
- spws 는 SharedPreferences 기본 사용과 비교하였을 때 보다 느릴 수 있습니다.
  데이터 암호화/복호화에 들어가는 연산량 + String 과 Json Object 간의 변환에 들어가는 연산량이 추가된 것입니다.
  이러한 방식으로 구현을 한 이유는, 추가되는 연산량을 통한 성능 저하보다 보안적 안전성, 개발시의 코드 통일성을 위한 것입니다.

[pages]

- 페이지를 모아둔 폴더입니다.
- 페이지는 정적 분류에 따라 사용 가능한 페이지가 갈리며, 이는 router.dart 파일 안에서 설정합니다.
- 서브 폴더는 정적 분류 기준으로 나뉩니다. (ex : all, app, mobile, web, ios...)

[pages/{정적분류}]

- 페이지를 정적 분류로 구분짓는 서브 폴더입니다.
- 내부에는 하나의 페이지에 대응하는 서브폴더가 존재하며,
  서브 폴더명은 앞에 {정적분류}_page_ 가 붙습니다.
  이와같이 정적 분류를 나타내는 접두어가 중복되어 들어간 이유는, include 시 as 로 별칭을 넣을 때,
  복사 붙여넣기를 편하게 하기 위해서입니다.

[pages/{정적분류}/{정적분류}_page_{폴더명}]

- 페이지 관련 폴더/파일을 저장하는 서브폴더입니다.
- 명명법이 특이한데, 다른 곳에서 import 시에 편의성을 위하여 접두어로 page 까지 하여 조건을 달고,
  뒤에 실제 페이지 의미가 담긴 이름을 붙인 것입니다. (import 시에 별칭은 해당 페이지 서브 폴더명을 그대로 사용하면 됩니다.)

[pages/{정적분류}/{정적분류}_page_{폴더명}/page_entrance.dart]

- 라우터를 통해 페이지에 진입할 때 처음 진입하는 입구 역할을 하는 파일입니다.
  라우터에는 페이지를 이것을 사용하여 등록하는 것입니다.
  추가로, 생명주기 처리, 공통 리스너 처리 등의 보일러 코드는 되도록 이곳에 모아뒀습니다.
  구조는 단순하기에 개발자는 커스텀할 공간이 몰려있는 하단 부분만 신경쓰면 됩니다.
- 파일 내의 코드에서 개발자는 !!! 를 검색해서, 해당 페이지의 라우터 경로명 설정, 페이지 호출/반납 애니메이션 설정, 입출력 데이터 형태를 커스텀을 할 수 있습니다.
- Page Input Value 관련 팁 :
  웹 브라우저의 쿼리 파라미터를 신경써야하는 Page 의 경우는 PageInputVo 를 만들 때 모든 변수의 타입을 nullable 로 선언하는 것이 좋습니다.
  일단 모든 변수를 nullable 로 선언한 후, 생명주기의 onPageCreateAsync 에서 변수 Null 체크를 수행하면 됩니다.
  이 경우 Nullable 변수와 그냥 변수를 구분하기 위하여, nullable 변수의 경우는 접미어로 Opt 를 붙이면 좋습니다.
  (ex : String? testTxtOpt;)
  Dialog 의 PageInputVo 는 위와 같은 처리를 하지 않아도 좋습니다.
- 페이지 진입 라우트 Name 정의.
  페이지 라우트명은 코드상으로만 사용되는 것이므로 고유성이 보장되기만 하면 됩니다.
  본 프로젝트에선 간단히, page 의 폴더명을 그대로 사용하면 됩니다.
- 페이지 애니메이션은 파일에서 초기 설정을 할 수 있으며, 코드상으로 해당하는 전역변수를 수정하여 런타임 시점의 변경도 가능합니다.

[pages/{정적분류}/{정적분류}_page_{폴더명}/page_view.dart]

- page_view.dart 는 페이지의 화면을 이루는 위젯 객체 구현을 분리하기 위해 나눈 파일입니다.
  여기선 비즈니스 로직과 관계가 없는 순수한 UI 관련 구현을 담당하며,
  비즈니스 로직은 여기에 작성하지 않고, PageBusiness 인스턴스를 사용하여 위임 합니다.
- 구현은 일반적인 화면 위젯을 배치하는 방식으로 개발을 진행해나가면 됩니다.
  이때, Stateless 위젯이라면 문제가 없지만, 런타임으로 변경이 가능한 Stateful 위젯의 경우는 BLoC 를 사용하여 처리합니다.
- BLoC 사용 부분이 존재한다면,
  먼저 해당하는 BLoC 정보를 Page_business.dart 파일 내에 작성합니다. (실제 예시 코드를 참고하세요.)
  상태 변화가 있는 곳은 BlocBuilder<BLoC 객체, bool> 로 감싸고,
  이벤트가 발생하여 builder 콜백이 실행되면 page_business 안의 page_view_model 안에서 필요한 정보를 가져와 사용합니다.

[pages/{정적분류}/{정적분류}_page_{폴더명}/page_business.dart]

- 페이지의 비즈니스 로직을 담당하는 파일입니다.
  page_view 에서 상호작용으로 실행될 비즈니스 로직, 페이지 생명주기에 따른 비즈니스 로직은 모두 여기서 처리하면 됩니다.
- 비즈니스 로직 외에 담당하는 다른 성질의 기능으로는, pageViewModel 로써, 페이지가 가진 모든 정보를,
  파일 안의 PageViewModel 클래스 안에 선언, 저장하여 사용합니다.
  새로 변수를 추가할 경우 우선적으로 이곳에 선언하여 사용하는 것을 고려하여 데이터를 한곳에 모아둡시다.
- 이외에 담당하는 다른 성질의 기능으로는, StateFul 상태 관리를 담당하는 BLoC 객체 작성 기능을 담당합니다.
  StateFul 상태 관리 관점에서의 BLoC 는 화면 내에 상태가 변화될 가능성이 존재하는 부분
  (위젯 하나가 될 수도 있고, 여러개가 될 수도 있습니다.)에 대한 조작 객체라 생각하면 됩니다.
  SQL 의 View 나, 이미지 프로세싱에서의 ROI 를 생각하면 되며, 원하는 단위로 화면을 조작하는 역할을 합니다.
- Flutter 에서 제공하는 BLoC 객체는 여러 기증을 지니고 있습니다만,
  본 프로젝트에서 BLoC 객체는 UI 갱신 기능만 사용하여, 이벤트의 발동 트리거로만 사용합니다.
  BLoC 객체의 state 저장 기능은 viewModel 이 담당하고,
  event 종류는 오로지 UI 변경 요청만을 수행한다고 단순화 시켰으며, 로직은 비즈니스 객체가 담당하도록 역할을 분리한 것입니다.
- BLoC 클래스는 위젯 단위로 생성합니다.
  위젯 단위의 생성은, 한 위젯이 Stateful 이라면 이에 대응하는 하나의 BLoC 를 만드는 것으로,
  하나의 이벤트에 대응하여 여러 위젯이 변하는 것을 가정하여 만든 이벤트 단위 BLoC 보다 코드량이 많아질수 있으나,
  재활용성이 높고 체계적이기에, 코드의 유연성을 높이기 위한 선택입니다.
- BLoC 클래스의 네이밍은 연결된 위젯에 따라서 작성합니다.
  예를들면 카운트 다운 넘버가 표시되는 위젯 부분에 적용되는 BLoC 클래스라면,
  BlocCountDownNumberText 이런식으로 작성하면 됩니다.

[dialogs]

- 커스텀 다이얼로그 관련 파일/폴더를 모아둔 폴더입니다.
- dialog 와 페이지의 차이로는,
  런타임 시점에, showDialog(context: context, builder: (context) => ExampleDialog());
  위와 같이 실행한다는 것과, 위젯 외곽 부분을 Dialog 위젯으로 감싼다는 것 외에는 다를게 전혀 없습니다.
  사실상, 다이얼로그 역시 View 와 Business Logic 의 세트로 이루어진 페이지라고 볼 수 있습니다.
  실제로 커스텀 다이얼로그를 구현할 때 역시, 페이지와 동일한 방식으로 dialogs 폴더 안에 관련 파일들을 작성하여 구현하면 됩니다.
- 다이얼로그 폴더의 구성과 개념은 페이지 폴더와 동일하기에 자세한 설명은 생략하겠습니다.

[Web 개발 주의사항]

- Flutter 의 멀티 플랫폼은 원래 모바일 앱 개발 통합으로 시작하여 PC 앱 개발까지 확장되었다가 Web 까지 확장된 것입니다.
  독립적으로 동작하는 앱과 달리 웹은 브라우저라는 앱 안에 별도의 규칙으로 동작하는 어플리케이션입니다.
- Flutter 에서 지원하는 웹은 SPA 입니다.
  그에 따른 UX, 개발법, 장/단점 등을 고려하여 개발 해야 합니다.
  예를들면, SPA 특성상 최초 로딩이 길다는 단점으로 인하여,
  단순히 웹 페이지 하나를 작성하려고 한다면 Flutter 웹 개발은 비효율적입니다.
- 테스트를 통해 확인한 웹의 동작 특성은 앱과 동일한 동작에 더하여 브라우저라는 변수가 적용됩니다. 아래와 같이 정리합니다.
- 브라우저 주소 입력시 어플리케이션이 새로 시작됨 :
  웹 브라우저에서 주소를 입력하여 웹 클라이언트에 접근한 경우, 해당 탭에서 어플리케이션이 새로 시작됩니다.
  즉, 전역변수 등의 정보가 이전에 입력한 상태와 이어지지 않고 초기화 된 상태로 새로 생성됩니다.
  이로 인하여 웹에서는 전역변수를 사용한 정보 공유에 의존해선 안되고, 꼭 필요하다면 Shared Preferences 와 같은 Storage 를 사용해야합니다.
- 새로고침시 어플리케이션이 새로 시작됨 : 브라우저 새로고침을 해도 어플리케이션이 새로 시작됩니다.
  브라우저 뒤로가기, 앞으로 가기 시에는 초기화 되지 않습니다.
- 브라우저 히스토리(뒤로가기, 앞으로가기)는 주소단위로 저장됩니다.
  예를들어 /a 라는 동일 주소를 코드 내에서 n번 호출하거나, 주소창에서 n번 호출해도 히스토리 상에는 /a 라는 주소는 한번만 저장된 것이 됩니다.
  주소의 연속성이 중요한 것으로, 만약 a -> a -> b -> b -> a 순서로 이동했다면, a 에서 브라우저 뒤로가기를 했을 때, b -> a 로 이동됩니다.
  또한, 브라우저 뒤로가기, 앞으로 가기로 이동한 경우엔 해당 페이지는 새로 생성한 것이 되므로, 기존의 페이지 뷰모델 정보가 저장되지 않습니다.
- 위와 같은 성질로 인해, 웹에선 페이지 뷰모델, 전역변수는 사용하지 않는 방식으로 개발하는 것이 좋습니다.

[Web SEO 관련 주의사항]

- 플러터의 Web 은 Client Side Rendering 로, 단순히 주소로 방문했을 때는 html 이 제 형태를 갖추지 않고,
  브라우저의 런타임 java script 해석을 통해야만 제대로된 html 이 생성됩니다.
- CSR(Client Side Rendering) 방식은 SSR(Server Side Rendering) 방식에 비하여 서버 부담을 줄이고 다이나믹한 화면을 구성할 수 있습니다.
  하지만, 구글과 같은 검색엔진의 웹사이트 탐색봇이 해당 주소를 탐색하기 위해 방문했을 때,
  아직 제대로된 화면이 생성되기 전이기에 봇에게는 해당 사이트에 대한 정보가 전달하지 않습니다.
  탐색 봇 중에는 HTML 이 아닌 JavaScript 를 읽어서 해당 페이지의 정보를 가져가는 고성능 봇도 있지만, 이것도 완벽하지는 않습니다.
  고로 CSR 을 그대로 사용한다면, 애써 만든 페이지가 아무리 공을 들이더라도 검색엔진에 표시가 되지 않는 현상이 일어날 수 있습니다.
- 일부러 방문량을 줄이려는 관리자 페이지나 개인 페이지를 제외해고는 수익과 영향력에 직결되는 검색엔진 추천 기능에 노출되고 싶을 텐데,
  이때는 seo_renderer 패키지의 코딩 규칙을 준수해야합니다.

  const regExp = new RegExp("bot|google|baidu|bing|msn|teoma|slurp|yandex", "i");
  if (regExp.test(navigator.userAgent)) {
  window.flutterWebRenderer = "html";
  }

  를 web/index.html 안의 <script> 블록 안에 추가하고,
  main.dart 의 main 함수에서 실행되는 runApp 에,

  runApp(
  // 검색 엔진 로봇 방문 감지
  RobotDetector(
  debug: gd_my_data.isDebugMode,
  child: MaterialApp.router(
  title: "Prowd Template",
  debugShowCheckedModeBanner: gd_my_data.isDebugMode,
  routerConfig: program_router.ProgramRouter().goRouter, // 라우트 경로 주입
  )));

  위와 같이 RobotDetector 로 감싸는 기본적인 설정 이후,
  각 페이지 별 내부 위젯을 작성할 때는 각 서브 위젯들을 Renderer 객체로 감싸주는 방식을 사용하면 됩니다.

  예를들어 Text 위젯이 있다고 할 때,

  TextRenderer(
  style: TextRendererStyle.paragraph,
  child: Text(
  'Lorem Ipsum is simply dummy text of the printing and typesetting industry.',
  ),
  )

  위와 같이 TextRenderer 로 감싸주면, 검색 엔진 로봇이 방문했을 때엔 미리 렌더링된 정보를 반환하여 주는 것입니다.

[Web SEO Renderer 객체 종류]

- 아래와 같은 SEO 객체들을 각 위젯 상위에 감싸주면 됩니다.
- TextRenderer : 위젯의 텍스트 정보를 랜더링 하여 봇에게 넘겨줌.
  TextRenderer(
  style: TextRendererStyle.paragraph,
  child: Text(
  'Lorem Ipsum is simply dummy text of the printing and typesetting industry.',
  ),
  )
  속성의 style 은, html 에서의 태그 종류를 설정하는 것인데,
  기본인 paragraph 는 p 태그, header1 은 h1 태그, 이런식입니다.
- LinkRenderer : 화면 내에 버튼을 눌렀을 때 다른 주소로 이동하는 기믹(href 태그)이 있다면 이를 추가해줍니다.
  LinkRenderer(
  text: 'Try Flutter',
  href: 'https://www.flutter.dev',
  child: ...,
  )
- ImageRenderer : 이미지 표시시, 해당 위젯이 이미지라는 것과, 그 설명을 전달합니다.
  ImageRenderer(
  alt: 'Network Image',
  child: Image.network('https://fakeimg.pl/300x300/?text=Network'),
  )